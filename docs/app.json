[{"name":"app.R","content":"# =============================================\r\n# APPLICATION SHINY : CARROT PROTOCOL SELECTOR\r\n# =============================================\r\n\r\n# We document the version of the code, which will appear in the Shiny app:\r\nversion <- \"Version: 2026-01-23\"\r\n\r\n# We define the path to the folder containing the documents:\r\nfolder_path <- \"D:/Documents/ECOSYS/3. PROJETS/RESEAUX RACINES/(Rhizos)PHARE/Article de synthèse/OAD/\"\r\n\r\n# # To install the required packages (to do only once - it is important to update readxl):\r\n# install.packages(\"shiny\")\r\n# install.packages(\"readxl\")\r\n# install.packages(\"stringr\")\r\n# install.packages(\"dplyr\")\r\n# install.packages(\"shinythemes\")\r\n# install.packages(\"DT\")\r\n# install.packages(\"shinyfullscreen\")\r\n\r\n# install.packages(\"shinylive\")\r\n# install.packages(\"httpuv\")\r\n\r\n# Loading the required packages:\r\nlibrary(readxl)\r\nlibrary(stringr)\r\nlibrary(dplyr)\r\nlibrary(shiny)\r\nlibrary(shinythemes)\r\nlibrary(DT)\r\n# library(shinyfullscreen) # Allows to automatically display the user interface in full screen\r\nlibrary(bslib)\r\n\r\nlibrary(shinylive)\r\nlibrary(httpuv)\r\n\r\n#TODO: \r\n# exudates: no recommended option for storage temperature - why?\r\n\r\n\r\n######################################################################################################\r\n######################################################################################################\r\n\r\n# Shiny is based on a user interface ('ui') and a server function ('server').\r\n\r\n# NOTE: Shiny provides a family of functions that turn R objects into output for the user interface. \r\n# Each function creates a specific type of output. \r\n# Ex: 'tableOutput' generates a table modified by the 'server' function outside the UI.\r\n\r\n# --- DEFINING THE USER INTERFACE (UI) ---\r\n\r\n# We build the user interface:\r\nui <- page_fillable(\r\n  \r\n  theme = shinytheme(\"spacelab\"),\r\n  # shinythemes::themeSelector(),\r\n  collapsible = TRUE,\r\n  # Customized color code for specific text lines and options:\r\n  tags$head(\r\n    tags$style(HTML(\"\r\n      body { background-color: white; color: black; }\r\n      h2 { font-family: 'Calibri', sans-serif;  color: orange; font-weight: bold; }\r\n      h4 { font-family: 'Calibri', sans-serif;  color: black; font-weight: bold; }\r\n      \r\n      .option-recommended { color: ForestGreen; font-weight: bold; }\r\n      .option-possible { color: YellowGreen; font-weight: bold; }\r\n      .option-incompatible { color: Crimson; text-decoration: line-through; }\r\n      .option-neutral { color: black; }\r\n    \")) # NOTE: Color names can be found on https://htmlcolorcodes.com/color-names/\r\n  ),\r\n  # Customized margins:\r\n  style=\"margin:2vw; margin-top: 0vw\",\r\n  \r\n  # We display the title:\r\n  h2(\"CARROT: Collecting and Analyzing Rhizodeposits - Reviewing and Optimizing Tool\"),\r\n  # p(\"\"),\r\n  # We display the version of the software, defined at the beginning of the code:\r\n  h6(version, style = \"font-weight: bold; font-style: italic\"),\r\n  hr(),\r\n  \r\n  # Defining the layout with a main panel and a side panel:\r\n  sidebarLayout(\r\n    \r\n    # DISPLAYING THE MAIN PANEL ON THE LEFT:\r\n    # --------------------------------------\r\n    mainPanel(\r\n      width = 6, # The width of the main panel. For fluid layouts this is out of 12 total units\r\n      style = \"height: 90vh; overflow-y: auto;\",\r\n      \r\n      # STARTING SCREEN (GROUP SELECTION)\r\n      conditionalPanel(\r\n        condition = \"output.screen == 'start'\",\r\n        \r\n        p(\"You first need to define where to start building your protocol.\"),\r\n        p(\"\"),\r\n        wellPanel(\r\n          h4(\"Please select a group of instructions:\"),\r\n          radioButtons(\"start_group\", \r\n                       \"\",\r\n                       choices = list(\r\n                         \"1: Scientific objectives\" = 1,\r\n                         \"2: Plant growth conditions\" = 2,\r\n                         \"3: Sampling strategy\" = 3,\r\n                         \"4: Sample processing before analysis\" = 4,\r\n                         \"5: Sample analysis\" = 5\r\n                       ),\r\n                       selected=1),  \r\n        ),\r\n        actionButton(\"button_start\", \"START\", class = \"btn-primary btn-lg\")\r\n      ),\r\n      \r\n      # NEW GROUP (GROUP SELECTION)\r\n      conditionalPanel(\r\n        condition = \"output.screen == 'move_to_next_group'\",\r\n        wellPanel(\r\n          h4(\"To continue building your protocol, please select a new group of instructions:\"),\r\n          radioButtons(\"continue_group\", \r\n                       \"\",\r\n                       choiceNames = list(\"html\", \"text\"),\r\n                       choiceValues = c(1,2),\r\n                       selected=1,\r\n          ),\r\n        ),\r\n        actionButton(\"button_continue\", \"CONTINUE\", class = \"btn-secondary btn-lg\")\r\n      ),\r\n      \r\n      # MAIN SCREEN (QUESTIONS)\r\n      conditionalPanel(\r\n        condition = \"output.screen == 'working'\",\r\n        \r\n        # We show the current group of instruction:\r\n        uiOutput(\"group_indicator\"), # Displays the current group\r\n        hr(), # Displays an horizontal limit\r\n        # We show a box to check if details about incompatible options are to be displayed:\r\n        conditionalPanel(\r\n          condition = \"output.incompatible_options\",\r\n          style = \"color: red; font-style: italic\",\r\n          checkboxInput(\"showing_incompatibility_details\", \"Show details about incompatible options\")\r\n        ),\r\n        # We show the current instruction and the possible options:\r\n        wellPanel(\r\n          h4(textOutput(\"current_instruction_title\")),\r\n          br(),\r\n          uiOutput(\"current_instruction_options\")\r\n        ),\r\n        # We show the buttons at the bottom, i.e. Next, Skip and possibly Back:\r\n        fluidRow(\r\n          column(6,\r\n                 conditionalPanel(\r\n                   condition = \"output.backwards_option == 'Allowed'\",\r\n                   actionButton(\"button_back\", \"Go back\", icon = icon(\"arrow-left\")),\r\n                 ),\r\n                 actionButton(\"button_skip\", \"Skip this\", icon = icon(\"forward\"))\r\n          ),\r\n          column(6, align = \"right\",\r\n                 actionButton(\"button_next\", \"Confirm and go to the next instruction\", class = \"btn-primary\")\r\n          )\r\n        )\r\n      ),\r\n      \r\n      # END SCREEN:\r\n      conditionalPanel(\r\n        condition = \"output.screen == 'all_groups_done'\",\r\n        h2(\"Congratulations!\"),\r\n        p(\"\"),\r\n        p(\"You have now covered all possible instructions.\"),\r\n        p(paste(\"You can download the final protocol in .csv or in .txt.\",\r\n                \"The first file corresponds to a table containing the instructions, and, for each one, the corresponding options along with their compatibility with previous choices, and the corresponding final choice.\",\r\n                \"The second file corresponds to a synthetic, complete summarized text corresponding to your protocol.\")),\r\n        p(\"\"),\r\n        p(\"You can leave the program here, restart from the beginning, or continue your exploration by re-visiting a specific group of instructions.\"),\r\n        p(\"\"),\r\n        actionButton(\"button_restart\", \"RE-START\"),\r\n        actionButton(\"button_resume\", \"RESUME\"),\r\n        # p(\"\"),\r\n        # h4(\"FINAL SUMMARY:\"),\r\n        # DTOutput(\"final_table\")\r\n      )\r\n    ),\r\n    \r\n    # DISPLAYING A SIDEBAR ON THE RIGHT:\r\n    #-----------------------------------\r\n    sidebarPanel(\r\n      \r\n      width = 6,\r\n      # style = \"height: 90vh; overflow-y: auto;\",\r\n      \r\n      tabsetPanel(\r\n        # id = \"hidden_tabs\",\r\n        # type = \"hidden\", # Hide the tab values. Can only switch tabs by using `updateTabsetPanel()\r\n        tabPanel(\r\n          # SHOWING A SUPPORTING TABLE\r\n          tags$b(\"Supporting Information\"),  \r\n          conditionalPanel(\r\n            condition = \"output.screen == 'working'\",  \r\n            style = \"height: 90vh; overflow-y: auto;\",\r\n            # h3(\"Supporting Information:\"),\r\n            tableOutput(\"SI_table\"),\r\n            # DT::DTOutput(\"SI_table\"),\r\n          ),\r\n        ),\r\n        tabPanel(\r\n          tags$b(\"Updated protocol\"),\r\n          conditionalPanel(\r\n            condition = \"nrow(values$history) > 1\",\r\n            # SHOWING THE DOWLOADING OPTIONS:\r\n            tabsetPanel(\r\n              tabPanel(\"As table\",\r\n                       # style = \"height: 90vh; overflow-y: auto;\",\r\n                       h4(\"Most recent choices:\"),\r\n                       h5(tableOutput(\"mini_history_table\")),\r\n                       # hr(), # Displays an horizontal limit\r\n                       downloadButton(\"download_protocol_csv\", \"Download the updated protocol (.csv)\"),),\r\n              tabPanel(\"As text\",\r\n                       # style = \"height: 90vh; overflow-y: auto;\",\r\n                       h4(\"Full text:\"),\r\n                       h5(uiOutput(\"protocol_full_text\")),\r\n                       downloadButton(\"download_protocol_text\", \"Download the updated protocol (.txt)\"),),\r\n            ),\r\n          ),\r\n        ),\r\n        tabPanel(\r\n          # SHOWING THE FINAL TABLE\r\n          tags$b(\"FINAL TABLE\"),\r\n          conditionalPanel(\r\n            condition = \"output.screen == 'all_groups_done'\",\r\n            style = \"height: 90vh; overflow-y: auto;\",\r\n            DT::DTOutput(\"final_table\"),\r\n          ),\r\n        ),\r\n      )\r\n    )\r\n  )\r\n)\r\n\r\n######################################################################################################\r\n######################################################################################################\r\n\r\n# --- DEFINING THE SERVER (where calculations are done) ---\r\n\r\n# The server function is run once each time a user visits the app.\r\n\r\nserver <- function(input, output, session) {\r\n  \r\n  # Input stores the current values of all of the widgets in your app. These values will be saved \r\n  # under the names that you gave the widgets in your ui.\r\n  \r\n  # Output contains variables that the UI can access. \r\n  # Each entry to output should contain the output of one of Shiny's render* functions. \r\n  # These functions capture an R expression and do some light pre-processing on the expression. \r\n  # Use the render* function that corrresponds to the type of reactive object you are making.\r\n  # Each render* function takes a single argument: an R expression surrounded by braces, {}.\r\n  # Define user specific objects inside server function, but outside of any render* calls. \r\n  # These would be objects that you think each user will need their own personal copy of. \r\n  # For example, an object that records the user's session information. This code will be run \r\n  # once per user. Only place code that Shiny must rerun to build an object inside \r\n  # of a render* function. Shiny will rerun all of the code in a render* chunk each time a user \r\n  # changes a widget mentioned in the chunk.\r\n  \r\n  # 1) DEFINITION OF REACTIVE VALUES\r\n  ##################################\r\n  \r\n  # Stores the values of the current application:\r\n  values <- reactiveValues(\r\n    screen = \"start\",                # Either 'start', 'move_to_next_group\", 'working', or 'finished'\r\n    decision_tree = data.frame(),    # Dataframe representing the Decision tree\r\n    information_tree = data.frame(), # Dataframe representing the Information tree\r\n    current_row = 4,                 # Current row in the Decision tree\r\n    max_row = 126,                   # Maximal row in the Decision tree\r\n    SI_table_name = \"Undocumented\",  # Name of the worksheet in which the SI table should be looked at\r\n    history = data.frame(),          # Dataframe recording the user choices\r\n    current_group_start=4,           # The row index corresponding to the start of the current group of instructions\r\n    current_group_end = 4,           # The row index corresponding to the end of the current group of instructions\r\n    incompatible_pending = NULL,     # Used to define an incompatible choice\r\n    current_instruction_options = \"\",# Used to store the full options to be downloaded\r\n    incompatible_options = FALSE,    # Used to display a button for allowing the user to get more details about incompatible options\r\n    protocol_full_text = \"\",         # Full text of the protocol to be displayed\r\n    last_text_added = \"\",            # Text that is added to the full protocol text at every choice made\r\n    backwards_option = \"Disabled\",   # Either \"Allowed\" or \"Disabled\"\r\n    current_group_ID = 1,            # Used to position the radio button option to the last grou^p selected\r\n    visited_groups_id = list(),      # List containing the ID number of the groups of instructions already visisted\r\n  )\r\n  \r\n  # 2) INITIALIZATION OF OUTPUT VALUES\r\n  ####################################\r\n  \r\n  # The screen is either displayed or not:\r\n  output$screen <- reactive({ values$screen })\r\n  outputOptions(output, \"screen\", suspendWhenHidden = FALSE) # This allow to use this as a condition in a conditionalPanel, even if the output is not shown\r\n  # We initialize the condition allowing the button \"Back\" to be displayed:\r\n  output$backwards_option = reactive({ values$backwards_option })\r\n  outputOptions(output, \"backwards_option\", suspendWhenHidden = FALSE) # This allow to use this as a condition in a conditionalPanel, even if the output is not shown\r\n  # We initialize the condition allowing the button \"Back\" to be displayed:\r\n  output$incompatible_options = reactive({ values$incompatible_options })\r\n  outputOptions(output, \"incompatible_options\", suspendWhenHidden = FALSE) # This allow to use this as a condition in a conditionalPanel, even if the output is not shown\r\n  # We initialize the current group ID number:\r\n  output$current_group_ID = reactive({ values$current_group_ID })\r\n  outputOptions(output, \"current_group_ID\", suspendWhenHidden = FALSE) # This \r\n  \r\n  # --- LOADING THE DATA ---\r\n  #-----------------------------------------------------------------------------------------------------\r\n  # We first define a function for loading the decision tree and the information tree:\r\n  load_data <- function(file_path, # Explicit path (ex: \"D:/Documents/\")\r\n                        worksheet=\"Decision tree\", # Name of the worksheet to load in the Excel file\r\n                        replace_this_character_by_white_space=\"\", # A character to be replaced by white space (necessary for a proper concatenation of strings)\r\n                        header=FALSE # Whether the first line corresponds to the header or not\r\n  ){\r\n    # We read the worksheet in the Excel file \r\n    raw_data <- read_excel(file_path, sheet = worksheet, col_names = header, na=\"NA\", col_types=\"text\",\r\n                           trim_ws=FALSE)\r\n    raw_data <- as.data.frame(raw_data)\r\n    # We replace a special character by a white space in all columns if necessary:\r\n    if (replace_this_character_by_white_space != \"\") {\r\n      raw_data <- raw_data %>%\r\n        select(everything()) %>%\r\n        dplyr::mutate_if(is.character, stringr::str_replace_all,\r\n                         pattern = replace_this_character_by_white_space, replacement = \" \")\r\n    }\r\n    return(raw_data)\r\n  }\r\n  #----------------------------------------------------------------------------------------------------\r\n  #----------------------------------------------------------------------------------------------------\r\n  # We attempt to load the initial data in the decision tree and in the information tree:\r\n  tryCatch({\r\n    # # NOT WORKING:\r\n    # values$decision_tree <- read.csv(input$file1$datapath)\r\n    # values$decision_tree <- renderTable({read.csv(input$file1$datapath, header=FALSE)})\r\n    \r\n    # WORKING:\r\n    dt_file_path = paste0(folder_path, \"CARROT.xlsm\")\r\n    values$decision_tree <- load_data(dt_file_path, worksheet = \"Decision tree\")\r\n    values$information_tree <- load_data(dt_file_path, worksheet = \"Information tree\",\r\n                                         # Because the stupid read_excel function removes cells with white spaces only, \r\n                                         # we have converted all white spaces in the original file and need to convert those back \r\n                                         # to white spaces:\r\n                                         replace_this_character_by_white_space=\"_\")\r\n    \r\n    # ATTEMPT:\r\n    # file_path <- renderText({input$file1$datapath})\r\n    # values$decision_tree <- load_data(file_path)\r\n    \r\n    # req(input$file1)\r\n    # values$decision_tree <- renderTable(input$file1)\r\n    # # To display the table in the UI:\r\n    # output$contents <- renderTable(input$file1) \r\n    \r\n    # req(input$path1)\r\n    # # values$decision_tree <- load_data(renderText({ input$path1 }))\r\n    # values$decision_tree <- read.csv(renderText({ input$path1 }))\r\n    \r\n  }, error = function(e) {\r\n    showNotification(\"ERROR: the file containing the decision tree could not be found. Please correct the path!\", type = \"error\", duration = NULL)\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # We define the Supporting Table to be displayed for the current choice.\r\n  SI_file_path = dt_file_path = paste0(folder_path, \"CARROT_SI.xlsx\")\r\n  output$SI_table <- renderTable(\r\n    # We load the datatable with the custom-made function 'load_data':\r\n    df <- head(load_data(SI_file_path,\r\n                         # We target the proper worksheet:\r\n                         worksheet = as.character(values$information_tree[[values$current_row, 3]]),\r\n                         # We allow the first line to be considered as the column names:\r\n                         header=TRUE),\r\n               # And we remove the last line corresponding to the link to the article using \"head\":\r\n               -1) %>%\r\n      # We need to replace the text in the cells so that line breaks are properly handled:\r\n      select(everything()) %>%\r\n      dplyr::mutate_if(is.character, stringr::str_replace_all,\r\n                       # We replace a line break \"\\n\" follow by \"o \" by a new line break in HTML, i.e. \"<br>\" followed by the sign \"o \":\r\n                       pattern = \"\\no \", replacement = \"<br>o \") %>%\r\n      # We replace the text in the first two columns so that it appears as bold:\r\n      dplyr::mutate(across(1:2, function(x) {return( paste(\"<b>\",x,\"<b>\") )})),\r\n    \r\n    colnames = TRUE,\r\n    bordered = TRUE,\r\n    striped = TRUE,\r\n    hover = TRUE,\r\n    spacing = \"s\", # The spacing between the rows of the table (xs stands for \"extra small\", s for \"small\", m for \"medium\" and l for \"large\")\r\n    align = \"l\", # If equal to 'l', 'c' or 'r', then all columns will be, respectively, left-, center- or right-aligned.\r\n    na = \"NA\",\r\n    sanitize.text.function=identity, # Allow to use HTML format in the text within the table\r\n  )\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # We detect automatically the row indices corresponding to the distinct groups of instructions:\r\n  groups_ranges <- list()\r\n  row_index <- 4            # Initialization of the row index in the Decision Tree\r\n  starting_index <- 4       # Initialization of the starting row index for the current group\r\n  list_index <- 1           # Initialization of the index in the final list\r\n  dt_file_path = paste0(folder_path, \"CARROT.xlsm\")\r\n  df <- load_data(dt_file_path, worksheet = \"Decision tree\")\r\n  # We initialize the group instruction:\r\n  current_group <- df[row_index,1]\r\n  previous_group <- df[row_index,1]\r\n  # For each row in the Decision tree:\r\n  while (row_index <= length(df) + 1) {\r\n    # If the new group instruction is different from the previously recorded one:\r\n    if (current_group != previous_group) {\r\n      # Then we define the ending index of the previous instruction:\r\n      ending_index <- row_index - 1\r\n      # We add a new item in the list of groups ranges:\r\n      groups_ranges[[list_index]] <- c(starting_index, ending_index)\r\n      list_index <- list_index + 1\r\n      # We define the staring index of the next group, and assign the previous group to this next group:\r\n      starting_index <- row_index\r\n      previous_group <- current_group\r\n    }\r\n    # In any case, we move to the next row:\r\n    row_index <- row_index + 1\r\n    if (row_index <= length(df)) {\r\n      current_group <- df[row_index,1]\r\n    } else {\r\n      # If the next group instruction cannot be accessed, we define it as \"END\":\r\n      current_group <- \"END\"\r\n    }\r\n  }\r\n  # Eventually, we record these ranges in the reactive values:\r\n  values$groups_ranges <- groups_ranges\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  # 3) CREATING INTERMEDIATE FUNCTIONS:\r\n  #####################################\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # CURRENT BLOCK - We analyze the block corresponding to the current instruction:\r\n  current_block <- reactive({\r\n    \r\n    # We first ensure that values are available \r\n    # - if not, the operation is stopped by raising a \"silent\" exception:\r\n    req(values$decision_tree, values$current_row <= values$current_group_end)\r\n    # We access the dataframe:\r\n    df <- values$decision_tree\r\n    # We define the current row index:\r\n    row_idx <- values$current_row\r\n    # We read the instruction to be displayed:\r\n    instruction_txt <- as.character(df[[2]][row_idx])\r\n    if(is.na(instruction_txt)) return(NULL)\r\n    \r\n    # Slicing up to the end of the current group of instructions:\r\n    col_2_slice <- df[[2]][row_idx:values$current_group_end]\r\n    # We look for the next instruction, i.e. the first line where the text differs:\r\n    is_same <- col_2_slice == instruction_txt\r\n    is_same[is.na(is_same)] <- FALSE\r\n    first_diff <- which(!is_same)[1]\r\n    # The length of the block of the current instruction is computed:\r\n    if (is.na(first_diff)) {\r\n      block_len <- length(col_2_slice)\r\n    } else {\r\n      block_len <- first_diff - 1\r\n    }\r\n    # The list of actual indices corresponding to the options of the current instruction are computed:\r\n    list_of_row_indices <- row_idx:(row_idx + block_len - 1)\r\n    # The text of the different options is defined as a vector:\r\n    options_text <- as.character(df[[3]][list_of_row_indices])\r\n    \r\n    # We return a list containing:\r\n    return(list(\r\n      # The text corresponding to the instruction:\r\n      instruction = instruction_txt,\r\n      # The indices corresponding to the options of this instructiong:\r\n      indices = list_of_row_indices,\r\n      # The vector containing the text of each option of the instruction:\r\n      options = options_text\r\n    ))\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # COMPATIBILITY -We define the compatibility of each option with previous choices:\r\n  options_with_compatibility <- reactive({\r\n    \r\n    # We initialize variables:\r\n    req(current_block())\r\n    block <- current_block()\r\n    hist <- values$history\r\n    df <- values$decision_tree\r\n    \r\n    # We initialize two lists for informing about the compatibility:\r\n    status_list <- character(length(block$indices))\r\n    conflict_list <- character(length(block$indices))\r\n    \r\n    # If no previous choices have been defined, everything is considered neutral:\r\n    if (nrow(hist) == 0) {\r\n      # We return a dataframe containing:\r\n      return(data.frame(\r\n        # The text of the options to be displayed:\r\n        text = block$options,\r\n        # The indices:\r\n        index = block$indices,\r\n        # The compatibility status defined as neutral:\r\n        status = \"Neutral\",\r\n        # The conflict defined as empty:\r\n        conflict = \"\",\r\n        stringsAsFactors = FALSE\r\n      ))\r\n    }\r\n    \r\n    # We initialize a counter corresponding to the number of the current options that are incompatible with previous choices:\r\n    number_of_incompatible_options <- 0\r\n    \r\n    # We loop over each possible option of the current instruction:\r\n    for (i in seq_along(block$indices)) {\r\n      \r\n      current_row_index <- block$indices[i]\r\n      # We initialize a vector containing the number of Recommended, Possible and Incompatible options:\r\n      counts <- c(Rec = 0, Poss = 0, Incomp = 0)\r\n      # We initialize a vector that will contain the incompatible previous choices:\r\n      conflicts <- c()\r\n      \r\n      # We go through each previous choices made by the user, by exploring the history:\r\n      for (h in seq_len(nrow(hist))) {\r\n        \r\n        prev_col <- hist$Col_Index[h]\r\n        if (is.na(prev_col) || prev_col < 0) next # If there was no previous choice, we go to the next choice:\r\n        \r\n        # We read the compatibility at the row corresponding to the current option and at the column corresponding to the previous choice:\r\n        val <- as.character(df[current_row_index, prev_col])\r\n        if (is.na(val)) val <- \"NA\"\r\n        # The counts vector is incremented according to the compatibility that has been read:\r\n        if (val == \"Fully compatible\") counts[\"Rec\"] <- counts[\"Rec\"] + 1\r\n        if (val == \"Possible but odd\") counts[\"Poss\"] <- counts[\"Poss\"] + 1\r\n        if (val == \"Incompatible\") {\r\n          counts[\"Incomp\"] <- counts[\"Incomp\"] + 1\r\n          # In case of incompatibility, we also add the previous choice in the conflicts vector:\r\n          conflicts <- c(conflicts, hist$Choice[h])\r\n        }\r\n      }\r\n      # After covering each previous choice, we update the lists of status and conflicts:\r\n      if (counts[\"Incomp\"] > 0) {\r\n        status_list[i] <- \"Incompatible\"\r\n        conflict_list[i] <- paste(conflicts, collapse = \", \")\r\n        number_of_incompatible_options <- number_of_incompatible_options + 1\r\n      } else if (counts[\"Poss\"] > 0) {\r\n        status_list[i] <- \"Possible\"\r\n      } else if (counts[\"Rec\"] > 0) {\r\n        status_list[i] <- \"Recommended\"\r\n      } else {\r\n        status_list[i] <- \"Neutral\"\r\n      }\r\n    }\r\n    \r\n    # In case there is at least one incompatible option to be shown:\r\n    if (number_of_incompatible_options > 0) {\r\n      # We record this information in the values, so that the possibility of showing more details is displayed:\r\n      values$incompatible_options <- TRUE\r\n    } else {\r\n      values$incompatible_options <- FALSE\r\n    }\r\n    \r\n    # If all options have been considered incompatible for the current instruction, a special event will be triggered later on:\r\n    if (number_of_incompatible_options == length(block$indices)) {\r\n      \r\n      block <- current_block()\r\n      # We define the next row index after the current block of instruction:\r\n      next_row <- max(block$indices) + 1\r\n      # We update the current row and verify that this index does not correspond to the end of the current group of instruction:\r\n      check_end(next_row)\r\n      # We document the text of the protocol:\r\n      values$last_text_added = \" [Instruction skipped automatically] \"\r\n    }\r\n    \r\n    # We finally return a dataframe containing:\r\n    return(data.frame(\r\n      # The text of the options to be displayed:\r\n      text = block$options,\r\n      # The indices:\r\n      index = block$indices,\r\n      # The compatibility status:\r\n      status = status_list,\r\n      # The conflict defined as empty:\r\n      conflict = conflict_list,\r\n      stringsAsFactors = FALSE\r\n    ))\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #---------------------------------------------------------------------------------------------------\r\n  # PROTOCOL TEXT - We define a function for extracting the text corresponding to the full text protocol:\r\n  get_protocol_text <- function(index) {\r\n    # We consider the first string piece:\r\n    element <- values$information_tree[[index, 4]]\r\n    if (is.na(element)) {\r\n      element <- \"\"\r\n    }\r\n    new_text <- element\r\n    # We add the middle string piece:\r\n    element <- values$information_tree[[index, 5]]\r\n    if (is.na(element)) {\r\n      element <- \"\"\r\n    }\r\n    new_text <- HTML(paste0(new_text, element))\r\n    # We add the final string piece:\r\n    element <- values$information_tree[[index, 6]]\r\n    if (is.na(element)) {\r\n      element <- \"\"\r\n    }\r\n    new_text <- paste0(new_text, element)\r\n    # We record this new piece of text, in case we need to remove it when clicking on the \"Back\" button:\r\n    values$last_text_added <- HTML(new_text)\r\n    \r\n  }\r\n  #---------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # CHECKING - We create a function for verifying whether we arrive at the end of a group of instruction:\r\n  check_end <- function(next_r) {\r\n    # If the next row index is higher than the maximal row number of the group:\r\n    if (next_r > values$current_group_end) {\r\n      # We check whether all groups have been covered or not, using the list of group ID that has been stored:\r\n      current_list <- values$visited_groups_id\r\n      expected_list <- list(1,2,3,4,5)\r\n      # We test whether the two lists contain the same items or not, regardless of the order:\r\n      if (identical(sort(unlist(current_list)), sort(unlist(expected_list)))) {\r\n        # Then we switch the screen in order to display the final screen:\r\n        values$screen <- \"all_groups_done\"\r\n      } else {\r\n        # Then we switch the screen in order to display the instructions for the next group:\r\n        values$screen <- \"move_to_next_group\"\r\n        \r\n        # And we update the corresponding radioButton to display already-examined groups in grey.\r\n        # We define the normal list to be displayed:\r\n        list_of_options <- list(\"1: Scientific objectives\",\r\n                                \"2: Plant growth conditions\",\r\n                                \"3: Sampling strategy\",\r\n                                \"4: Sample processing before analysis\",\r\n                                \"5: Sample analysis\")\r\n        # We initialize the new list to be displayed with the HTML code:\r\n        new_HTML_list <- list_of_options\r\n        # We cover each group:\r\n        for (ID in seq(1,5)) {\r\n          # If the group corresponding to the current ID has been visited:\r\n          if (ID %in% values$visited_groups_id) {\r\n            special_format <- paste0(\"<p style='color: grey; margin-bottom:0; padding-top:0;'<\/p>\",list_of_options[[ID]])\r\n            new_HTML_list[[ID]] <- HTML(special_format)\r\n          } else {\r\n            special_format <- paste0(\"<p style='color: black; margin-bottom:0; padding-top:0;'<\/p>\",list_of_options[[ID]])\r\n            new_HTML_list[[ID]] <- HTML(special_format)\r\n          }\r\n        }\r\n        \r\n        updateRadioButtons(session, \"continue_group\",\r\n                           # tags$style(HTML(\"line-height:3;\")),\r\n                           choiceNames = new_HTML_list, \r\n                           choiceValues = c(1,2,3,4,5),\r\n                           selected=values$current_group_ID)\r\n        \r\n      }\r\n      # Otherwise, we continue the current group of instruction and just move to the next one\r\n      # by assigning the current row to the next one that had been computed:\r\n    } else {\r\n      values$current_row <- next_r\r\n    }\r\n  }\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # SAVING - We define a function that saves the current decision and move to the next instruction:\r\n  save_step <- function(row_idx, user_choice) {\r\n    \r\n    # df <- values$decision_tree\r\n    df <- values$decision_tree\r\n    instruction <- as.character(df[row_idx, 2])\r\n    \r\n    # The column containing the instructions is recorded:\r\n    instructions <- as.character(df[2, ])\r\n    # The column containing possible choices is recorded:\r\n    choices <- as.character(df[3, ])\r\n    \r\n    # We look for the column index matching the choice of the user:\r\n    match_col <- which(choices == user_choice & instructions == instruction)\r\n    final_col <- if(length(match_col) > 0) match_col[1] else -1\r\n    \r\n    # 2. We define a new entry for the history dataframe containing the choice of the user:\r\n    new_entry <- data.frame(\r\n      Group_ID = values$current_group_ID,\r\n      Group = as.character(df[row_idx, 1]),\r\n      Instruction = instruction,\r\n      Options = writing_options_as_text(),\r\n      Choice = user_choice,\r\n      Row_Index = row_idx,\r\n      Col_Index = final_col,\r\n      Protocol_text = values$last_text_added,\r\n      stringsAsFactors = FALSE\r\n    )\r\n    # We combine the entry with the history dataframe:\r\n    values$history <- rbind(values$history, new_entry)\r\n    # We update the full text of the protocol by concatenating the whole corresponding column in 'history'\r\n    # after arranging the rows according to the ascending order of Group_ID:\r\n    arranged_history <- values$history %>% arrange(Group_ID)\r\n    values$protocol_full_text <- HTML(paste0(arranged_history$Protocol_text))\r\n    output$protocol_full_text <-  renderUI({values$protocol_full_text})\r\n    # We define the next row index after the current block of instruction:\r\n    block <- current_block()\r\n    next_row <- max(block$indices) + 1\r\n    # We verify that this index does not correspond to the end of the current group of instruction.\r\n    # If so, the screen is changing. If not, the current row is updated with \"next_row\" by the function check_end,\r\n    # effectively moving to the next instruction:\r\n    check_end(next_row)\r\n  }\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  # 4) RENDERING OUTPUTS\r\n  #######################\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # The current instruction is recorded for being displayed in the UI:\r\n  output$current_instruction_title <- renderText({\r\n    req(current_block())\r\n    current_block()$instruction\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # The options to be displayed are now defined:\r\n  output$current_instruction_options <- renderUI({\r\n    \r\n    # We define the options compatibility (as described above):\r\n    req(options_with_compatibility())\r\n    opts <- options_with_compatibility()\r\n    \r\n    # 1. The indices are transformed as a character vector:\r\n    ids <- as.character(opts$index)\r\n    \r\n    # 2. The labels to be displayed in HTML are now defined:\r\n    html_labels <- lapply(seq_len(nrow(opts)), function(i) {\r\n      # NOTE: We used lapply to treat each line without index error.\r\n      # The text of the option is defined:\r\n      txt <- as.character(opts$text[i])\r\n      # The compatibility of the option is defined:\r\n      stat <- as.character(opts$status[i])\r\n      # The conflicts with previous choices is defined:\r\n      conflict <- as.character(opts$conflict[i])\r\n      \r\n      # We choose a CSS class:\r\n      css_class <- switch(stat,\r\n                          \"Recommended\" = \"option-recommended\",\r\n                          \"Possible\" = \"option-possible\",\r\n                          \"Incompatible\" = \"option-incompatible\",\r\n                          \"option-neutral\") # option_neutral is the default value\r\n      \r\n      # We choose a prefix to be displayed before the option itself:\r\n      prefix <- switch(stat,\r\n                       \"Recommended\" = \"[RECOMMENDED] \",\r\n                       \"Possible\" = \"[POSSIBLE] \",\r\n                       \"Incompatible\" = \"[INCOMPATIBLE] \",\r\n                       \"\") # \"\" is the default value\r\n      \r\n      # We build the HTML string corresponding to the option to be displayed: \r\n      label_str <- paste0(\"<span class='\", css_class, \"'>\", i, \": \", prefix, txt, \"<\/span>\")\r\n      \r\n      # We add the detail of incompatible previous choices if necessary:\r\n      if (stat == \"Incompatible\" & input$showing_incompatibility_details == TRUE) {\r\n        label_str <- paste0(label_str, \"<br><small style='color:red'> (Incompatible with: \", conflict, \")<\/small>\")\r\n      }\r\n      \r\n      # We return the HTML string to be displayed for the option:\r\n      return(HTML(label_str))\r\n    })\r\n    \r\n    # 3. We create the buttons for choosing the options (NOTE: unname() is used to avoid troubles)\r\n    radioButtons(\"user_selection\", label = NULL, \r\n                 choiceNames = unname(html_labels),\r\n                 choiceValues = unname(ids))\r\n    \r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  # We record the options for later saving them in the history table:\r\n  writing_options_as_text <- function() {\r\n    \r\n    # We define the options compatibility (as described above):\r\n    req(options_with_compatibility())\r\n    opts <- options_with_compatibility()\r\n    \r\n    # We initialize the final text:\r\n    all_options_text = \"\"\r\n    \r\n    # The text is defined for each possible option:\r\n    for (i in seq_len(nrow(opts))) {\r\n      \r\n      # The text of the option is defined:\r\n      option_text <- as.character(opts$text[i])\r\n      # The compatibility of the option is defined:\r\n      option_status <- as.character(opts$status[i])\r\n      # The conflicts with previous choices is defined:\r\n      conflict <- as.character(opts$conflict[i])\r\n      \r\n      # We define a class according to the status of compatibility:\r\n      css_class <- switch(option_status,\r\n                          \"Recommended\" = \"option-recommended\",\r\n                          \"Possible\" = \"option-possible\",\r\n                          \"Incompatible\" = \"option-incompatible\",\r\n                          \"option-neutral\") # option_neutral is the default value\r\n      \r\n      # We define a prefix to display according to the status of compatibility:\r\n      prefix <- switch(option_status,\r\n                       \"Recommended\" = \"[RECOMMENDED] \",\r\n                       \"Possible\" = \"[POSSIBLE] \",\r\n                       \"Incompatible\" = \"[INCOMPATIBLE] \",\r\n                       \"\") # \"\" is the default value\r\n      \r\n      # We build the complete text corresponding to the option to be displayed and add it to the previous text: \r\n      all_options_text <- paste0(all_options_text, prefix, option_text, \"\\n\")\r\n      \r\n      # We add the detail of incompatible previous choices if necessary:\r\n      if (option_status == \"Incompatible\") {\r\n        all_options_text <- paste0(all_options_text, \"   > Incompatible with: \", conflict, \"\\n\")\r\n      }\r\n    }\r\n    \r\n    return (all_options_text)\r\n  }\r\n  \r\n  # values$current_instruction_options <- as.character(reactive({writing_options_as_text()}))\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  \r\n  # 5) REACTING TO THE USER ACTION\r\n  ################################\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # STARTING BY DEFINING THE FIRST GROUP OF INSTRUCTION:\r\n  # We define what happens after clicking on Start:\r\n  observeEvent(input$button_start, {\r\n    \r\n    # We get the ID number of the group of instruction chosen by the user:\r\n    current_group_ID <- as.numeric(input$start_group)\r\n    values$current_group_ID <- current_group_ID\r\n    # If this ID number has not been included in the list 'visited_groups_id' so far, we add it:\r\n    if (!(current_group_ID %in% values$visited_groups_id)) {\r\n      values$visited_groups_id <- append(values$visited_groups_id, current_group_ID)\r\n    }\r\n    \r\n    # We get the starting and ending row index for the instructions corresponding to this group:\r\n    ranges <- values$groups_ranges[[as.character(current_group_ID)]]\r\n    ranges <- values$groups_ranges[[current_group_ID]]\r\n    values$current_row <- ranges[1]\r\n    values$current_group_start <- ranges[1]\r\n    values$current_group_end <- ranges[2]\r\n    # We allow showing the screen:\r\n    values$screen <- \"working\"\r\n    \r\n    # We initialize the history table, e.g. with Group, Instruction, Choice:\r\n    values$history <- data.frame(\r\n      Group_ID = numeric(),\r\n      Group = character(),\r\n      Instruction = character(),\r\n      Options = character(),\r\n      Choice = character(),\r\n      Row_Index = numeric(),\r\n      Col_Index = numeric(),\r\n      Protocol_text = character(),\r\n      stringsAsFactors = FALSE\r\n    )\r\n    \r\n    # And we forbid using the \"Back\" button at the next step:\r\n    values$backwards_option <- \"Disabled\"\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # CONTINUING WITH A NEW GROUP OF INSTRUCTIONS:\r\n  # We define what happens after clicking on Continue:\r\n  observeEvent(input$button_continue, {\r\n    \r\n    # We get the ID number of the group of instruction chosen by the user:\r\n    current_group_ID <- as.numeric(input$continue_group)\r\n    values$current_group_ID <- current_group_ID\r\n    # If this ID number has not been included in the list 'visited_groups_id' so far:\r\n    if (!(current_group_ID %in% values$visited_groups_id)) {\r\n      # We add it:\r\n      values$visited_groups_id <- append(values$visited_groups_id, current_group_ID)\r\n      # We get the starting and ending row index for the instructions corresponding to this group:\r\n      ranges <- values$groups_ranges[[current_group_ID]]\r\n      values$current_row <- ranges[1]\r\n      values$current_group_start <- ranges[1]\r\n      values$current_group_end <- ranges[2]\r\n      # We now allow moving to another type of screen:\r\n      values$screen <- \"working\"\r\n      # And we forbid using the \"Back\" button at the next step:\r\n      values$backwards_option <- \"Disabled\"\r\n    } else {\r\n      # We create a dialog box to confirm the choice of revisiting the group:\r\n      showModal(modalDialog(\r\n        title = \"WATCH OUT! This group of instructions has already been covered. Revisiting it will erase the previous answers. Do you wish to proceed?\",\r\n        footer = tagList(\r\n          modalButton(\"Cancel\"),\r\n          actionButton(\"button_confirm_revisiting\", \"Confirm\", class = \"btn-danger\")\r\n        )\r\n      ))\r\n    }\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # NEXT: We set up the action following the click on the \"Next\" button (i.e. Confirm):\r\n  observeEvent(input$button_next, {\r\n    req(input$user_selection)\r\n    # We define the index corresponding to the user choice:\r\n    selected_idx <- as.numeric(input$user_selection)\r\n    # We define the compatibility of this choice with previous choices:\r\n    opts <- options_with_compatibility()\r\n    # We define the text of the final choice:\r\n    selected_opt <- opts[opts$index == selected_idx, ]\r\n    \r\n    # If the choice of the user is incompatible with previous choices:\r\n    if (selected_opt$status == \"Incompatible\") {\r\n      values$incompatible_pending <- selected_opt\r\n      # We create a dialog box to confirm the choice:\r\n      showModal(modalDialog(\r\n        title = \"WATCH OUT!\",\r\n        HTML(paste0(\"You have selected an option that is incompatible with previous choices :<br><b>\", \r\n                    selected_opt$conflict, \"<\/b><br><br>Do you really want to select this option?\")),\r\n        footer = tagList(\r\n          modalButton(\"Cancel\"),\r\n          actionButton(\"button_confirm_incompatible\", \"Confirm\", class = \"btn-danger\")\r\n        )\r\n      ))\r\n      # Else, if the choice of the user is compatible with previous choices:\r\n    } else {\r\n      \r\n      # We set the text corresponding to the protocol to be displayed \r\n      # (values$last_text_added is updated):\r\n      get_protocol_text(selected_idx)\r\n      # We save the present choice, update the items of values, and finally go to the next step:\r\n      save_step(selected_idx, selected_opt$text)\r\n    }\r\n    \r\n    # We allow to display the \"Back\" button at the next step:\r\n    output$backwards_option <- reactive({\"Allowed\"})\r\n    \r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # CONFIRM INCOMPATIBLE: In case the user has selected an incompatible choice and confirmed his/her choice:\r\n  observeEvent(input$button_confirm_incompatible, {\r\n    # We remove the Dialog Box:\r\n    removeModal()\r\n    req(values$incompatible_pending)\r\n    # We set the text corresponding to the protocol to be displayed \r\n    # (values$last_text_added is updated):\r\n    get_protocol_text(values$incompatible_pending$index)\r\n    # We save the present choice, update the items of values, and finally go to the next step:\r\n    save_step(values$incompatible_pending$index, values$incompatible_pending$text)\r\n    # We reset the incompatible pending table:\r\n    values$incompatible_pending <- NULL\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # CONFIRM REVISITING A GROUP: In case the user has decided to revisit a group previously examined:\r\n  observeEvent(input$button_confirm_revisiting, {\r\n    # We remove the Dialog Box:\r\n    removeModal()\r\n    # If the user confirms this, we erase the answers from the history table:\r\n    values$history <- values$history %>%\r\n      filter(Group_ID != values$current_group_ID)\r\n    # We get the starting and ending row index for the instructions corresponding to this group:\r\n    ranges <- values$groups_ranges[[values$current_group_ID]]\r\n    values$current_row <- ranges[1]\r\n    values$current_group_start <- ranges[1]\r\n    values$current_group_end <- ranges[2]\r\n    # We now allow moving to another type of screen:\r\n    values$screen <- \"working\"\r\n    # And we forbid using the \"Back\" button at the next step:\r\n    values$backwards_option <- \"Disabled\"\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # SKIP: We define what happens after clicking on the \"Skip\" button:\r\n  observeEvent(input$button_skip, {\r\n    \r\n    # We define the current block:\r\n    block <- current_block()\r\n    # We make a special entry in the history table for the case where the instruction has been skipped:\r\n    new_entry <- data.frame(\r\n      Group_ID = values$current_group_ID,\r\n      Group = as.character(values$decision_tree[block$indices[1], 1]),\r\n      Instruction = block$instruction,\r\n      Options = writing_options_as_text(),\r\n      Choice = \"[Skip this instruction]\",\r\n      Row_Index = values$current_row,\r\n      Col_Index = values$current_row,\r\n      Protocol_text = \" [Instruction skipped] \",\r\n      stringsAsFactors = FALSE\r\n    )\r\n    # We combine the entry with the history dataframe:\r\n    values$history <- rbind(values$history, new_entry)\r\n    # We reset the protocol full text:\r\n    values$last_text_added <- \" [Instruction skipped] \"\r\n    # We update the concatenated text corresponding to the protocol:\r\n    values$protocol_full_text <- HTML(paste0(values$history$Protocol_text))\r\n    output$protocol_full_text <-  renderUI({values$protocol_full_text})\r\n    # We define the next row index after the current block of instruction:\r\n    next_row <- max(block$indices) + 1\r\n    # We verify that this index does not correspond to the end of the current group of instruction:\r\n    check_end(next_row)\r\n  })  \r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # BACK: We define what happens after clicking on \"Back\":\r\n  observeEvent(input$button_back, {\r\n    \r\n    # We need to remove the last entry in the history (if any), and to update the row index.\r\n    if(nrow(values$history) > 0) {\r\n      \r\n      # We get the last entry in the history table:\r\n      last_entry <- tail(values$history, 1)\r\n      if (last_entry$Row_Index > 0) {\r\n        # We need to move back to the row index of the beginning of the instruction:\r\n        target_row <- last_entry$Row_Index\r\n        curr_inst <- as.character(values$decision_tree[target_row, 2])\r\n        # We move backwards until the instruction is changed\r\n        while(target_row > 1 && as.character(values$decision_tree[target_row - 1, 2]) == curr_inst) {\r\n          target_row <- target_row - 1\r\n        }\r\n        # And we finally update the row index\r\n        values$current_row <- target_row\r\n      } else {\r\n        # NOTE: this case should not happen!\r\n        showNotification(\"WATCH OUT: A problem was encountered when trying to move back!\", type=\"warning\")\r\n        \r\n        # # We first need to move back to the row index of the beginning of the instruction:\r\n        # target_row <- values$current_row\r\n        # curr_inst <- as.character(values$decision_tree[target_row, 2])\r\n        # # We move backwards until the instruction is changed\r\n        # while(target_row > 1 && as.character(values$decision_tree[target_row - 1, 2]) == curr_inst) {\r\n        #   target_row <- target_row - 1\r\n        # }\r\n        # # Now we repeat the operation to actually move to the previous instruction:\r\n        # curr_inst <- as.character(values$decision_tree[target_row, 2])\r\n        # # We move backwards until the instruction is changed\r\n        # while(target_row > 1 && as.character(values$decision_tree[target_row - 1, 2]) == curr_inst) {\r\n        #   target_row <- target_row - 1\r\n        # }\r\n        # # And we finally update the row index\r\n        # values$current_row <- target_row\r\n      }\r\n      \r\n      # We update the current block:\r\n      block <- current_block()\r\n      \r\n      # We update the history table by removing the last line:\r\n      values$history <- head(values$history, -1)\r\n      \r\n      # We update the concatenated text corresponding to the protocol, after arranging the rows according to the ascending order of Group_ID:\r\n      arranged_history <- values$history %>% arrange(Group_ID)\r\n      values$protocol_full_text <- HTML(paste0(arranged_history$Protocol_text))\r\n      output$protocol_full_text <- renderUI({values$protocol_full_text})\r\n      # We update the last text added:\r\n      values$last_text_added <-  \"\"\r\n      \r\n      # We verify that the new row is not equal to the first row of the current group of instruction.\r\n      if (values$current_row == values$current_group_start) {\r\n        # If so, we forbid using the \"Back\" button at the next step:\r\n        values$backwards_option <- \"Disabled\"\r\n        output$backwards_option <- reactive({\"Disabled\"})\r\n      }\r\n    }\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # RESTART FROM THE BEGINNING:\r\n  # We define what happens after clicking on RESTART:\r\n  observeEvent(input$button_restart, {\r\n    # We now allow moving to another type of screen:\r\n    values$screen <- \"start\"\r\n    # And we forbid using the \"Back\" button at the next step:\r\n    values$backwards_option <- \"Disabled\"\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  #----------------------------------------------------------------------------------------------------\r\n  # RESUME THE EXPLORATION:\r\n  # We define what happens after clicking on RESTART:\r\n  observeEvent(input$button_resume, {\r\n    # We now allow moving to another type of screen:\r\n    values$screen <- \"move_to_next_group\"\r\n    # And we forbid using the \"Back\" button at the next step:\r\n    values$backwards_option <- \"Disabled\"\r\n  })\r\n  #----------------------------------------------------------------------------------------------------\r\n  \r\n  # 6) OPTIONAL DISPLAY\r\n  #####################\r\n  \r\n  # Option for special display according to the current group of instruction:\r\n  output$group_indicator <- renderUI({\r\n    req(current_block())\r\n    grp <- as.character(values$decision_tree[values$current_row, 1])\r\n    tagList(\r\n      tags$b(\"Current group: \"), # br(),\r\n      span(grp, style = \"color: #3498db; font-weight: bold\")\r\n    )\r\n  })\r\n  \r\n  # # Option for controlling the display of tabs:\r\n  # observeEvent(input$controller, {\r\n  #   updateTabsetPanel(session, \"hidden_tabs\", selected = paste0(\"panel\", input$controller))\r\n  # })\r\n  \r\n  # Option for creating a summarized history table with only Instruction and Choice:\r\n  output$mini_history_table <- renderTable({\r\n    req(values$history)\r\n    if(nrow(values$history) == 0) return(NULL)\r\n    tail(values$history[, c(\"Instruction\", \"Choice\")], 5)\r\n  }, colnames = FALSE)\r\n  \r\n  # Option for displaying the final table:\r\n  output$final_table <- renderDT({\r\n    req(values$history)\r\n    datatable(values$history[, c(\"Group\", \"Instruction\", \"Choice\")], \r\n              options = list(pageLength = 50))\r\n  })\r\n  \r\n  # Options for downloading the final protocol as CSV file:\r\n  output$download_protocol_csv <- downloadHandler(\r\n    filename = function() { paste(\"CARROT_Protocol_\", Sys.Date(), \".csv\", sep=\"\") },\r\n    content = function(file) {\r\n      # We select only the columns of interest in the 'history' table:\r\n      write.csv(values$history[, c(\"Group\", \"Instruction\", \"Options\", \"Choice\")], file, row.names = FALSE)\r\n    }\r\n  )\r\n  # Options for downloading the final protocol as .txt file:\r\n  output$download_protocol_text <- downloadHandler(\r\n    filename = function() { paste(\"CARROT_Protocol_\", Sys.Date(), \".txt\", sep=\"\") },\r\n    content = function(file) {\r\n      writeLines(values$protocol_full_text, file)\r\n    }\r\n  )\r\n  \r\n}\r\n\r\n######################################################################################################\r\n######################################################################################################\r\n\r\n# --- LAUNCHING THE PROGRAM WITH SHINY ---\r\nshinyApp(ui = ui, server = server)","type":"text"},{"name":"carrot.Rproj","content":"Version: 1.0\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 2\r\nEncoding: ISO8859-1\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n","type":"text"}]
